#! /usr/bin/ruby

# cs-commons helper script.
# Provides useful automation for creation and maintenance of
# cs-commons sites and artifacts.

require 'readline'
require 'json'

MASTER_SITE = "https://raw.githubusercontent.com/cs-commons/template-site/master"

# Required site metadata entries (and descriptions)
REQUIRED_SITE_METADATA = {
	'site_url' => 'URL where site will be hosted',
	'title' => 'Title to display on index page',
	'repo_git_url' => 'Git repository URL',
	'repo_pub_url' => 'Public URL of Git repository',
}

GITHUB_URL_RE = /^git@github.com:([^\/]+)\/([^\/]+)\.git$/

# ----------------------------------------------------------------------
# Util class - utility functions
# ----------------------------------------------------------------------
class Util
	def self.ask(prompt)
		buf = Readline.readline(prompt, true)
		return buf
	end

	def self.ask_yn(prompt)
		buf = Readline.readline("#{prompt} (yes/no) ", true)
		return buf.downcase == 'y' || buf.downcase == 'yes'
	end

	def self.run(*cmd)
		raise "command #{cmd[0]} failed" if !system(*cmd)
	end

	def self.run_quiet(*cmd)
		raise "command #{cmd[0]} failed" if !system(*cmd, out: '/dev/null', err: '/dev/null')
	end

	def self.mkdir(dirname)
		run('mkdir', '-p', dirname)
	end

	def self.task(message)
		print "#{message}..."
		STDOUT.flush
		yield
		puts "done"
	end

	def self.copy_template_file(dirname, template_file)
		Dir.chdir(dirname) do
			if m = /^(.*)\/[^\/]+$/.match(template_file)
				#puts "making directory: #{m[1]}"
				mkdir(m[1])
			end
			task("Copying #{template_file}") do
				run_quiet( 'wget', "#{MASTER_SITE}/#{template_file}", "--output-document=#{template_file}")
			end
		end
	end

	def self.create_file(dirname, filename, contents)
		task("Creating #{filename}") do
			File.open("#{dirname}/#{filename}", "w") do |f|
				f.print(contents)
			end
		end
	end

	def self.find_files_in(dirname, extension)
		result = []
		Dir.chdir(dirname) do
			IO.popen("find . -name '*\\.#{extension}' -print") do |io|
				io.each_line do |line|
					line.chomp!
					result.push(line[2..line.length])
				end
			end
		end
		return result
	end

	def self.is_site?
		return File.exists?('cs-commons-site.json')
	end

	def self.is_github_url?(url)
		return GITHUB_URL_RE.match(url) ? true : false
	end

	def self.parse_github_url(url)
		m = GITHUB_URL_RE.match(url)
		throw "#{url} is not a GitHub url" if !m
		return [m[1], m[2]]
	end
		
end

# ----------------------------------------------------------------------
# Base class for commands
# ----------------------------------------------------------------------
class Command
	attr_reader :name, :args, :helptext

	def initialize(name, args, helptext)
		@name = name
		@args = args
		@helptext = helptext
	end

	@@commands = {}

	def self.add(cmd)
		@@commands[cmd.name] = cmd
	end

	def self.all
		@@commands
	end
end

# ----------------------------------------------------------------------
# Command to print out help information for each command
# ----------------------------------------------------------------------
class Help < Command
	def initialize
		super("help", "", "print synopsis of each command")
	end

	def exec(args)
		puts "Commands:"
		commands = Command.all
		commands.keys.sort.each do |command_name|
			cmd = commands[command_name]
			# TODO: nicer formatting
			puts "  #{cmd.name} #{cmd.args} #{cmd.helptext}"
		end
	end
end

# ----------------------------------------------------------------------
# Command to create a new site
# ----------------------------------------------------------------------
class CreateSite < Command
	def initialize
		super("create-site", "<sitename>", "create a new cs-commons site (e.g., for a course)")
	end

	def exec(args)
		raise "missing sitename" if args.length != 1
		sitename = args[0]

		site_meta = {}

		repo_git_url = Util.ask("#{REQUIRED_SITE_METADATA['repo_git_url']}: ")
		site_meta['repo_git_url'] = repo_git_url

		# If the git URL is at GitHub, then we can predict the
		# site URL and the repo public URL
		if Util.is_github_url?(repo_git_url)
			puts "You're using GitHub, excellent."
			github_user, github_repo = Util.parse_github_url(repo_git_url)
			site_url = "http://#{github_user}.github.io/#{github_repo}"
			repo_pub_url = "https://github.com/#{github_user}/#{github_repo}"
			puts "I predict that you will want to use the following values:"
			puts "  #{REQUIRED_SITE_METADATA['site_url']}: #{site_url}"
			puts "  #{REQUIRED_SITE_METADATA['repo_pub_url']}: #{repo_pub_url}"
			ok = Util.ask_yn("Are these values correct?")
			if ok
				site_meta['site_url'] = site_url
				site_meta['repo_pub_url'] = repo_pub_url
			end
		end

		REQUIRED_SITE_METADATA.keys.sort.each do |key|
			if !site_meta.has_key?(key)
				descr = REQUIRED_SITE_METADATA[key]
				site_meta[key] = Util.ask("#{descr}: ")
			end
		end

		# Copy files from template site
		Util.mkdir(sitename)
		# FIXME: probably we should attempt to fetch the entire template site
		Util.copy_template_file(sitename, "js/cs-commons.js")
		Util.copy_template_file(sitename, "css/site.css")
		Util.copy_template_file(sitename, "_layouts/default.html")
		Util.copy_template_file(sitename, "_layouts/fragment.html")

		# Generate _config.yml
		Util.create_file(sitename, "_config.yml", <<"EOF")
url: "#{site_meta['site_url']}"
markdown: rdiscount
pygments: true
EOF

		# Generate index.md
		Util.create_file(sitename, "index.md", <<"EOF")
---
layout: default
title: "#{site_meta['title']}"
---

Welcome to the site!

There is nothing here yet.
EOF

		# Generate .gitignore
		Util.create_file(sitename, ".gitignore", <<"EOF")
*.swp
*~
EOF

		# Generate cs-commons-site.json
		site_json = JSON.fast_generate(site_meta)
		Util.create_file(sitename, "cs-commons-site.json", site_json)
	end
end

# ----------------------------------------------------------------------
# Command to make a git repository for site, check in initial
# files and commit them to a gh-pages branch
# ----------------------------------------------------------------------
class Checkin < Command
	def initialize
		super("checkin", "", "check site files into local git repository")
	end

	def exec(args)
		raise "This directory doesn't seem to be a cs-commons site" if !Util.is_site?

		site_meta = JSON.parse(IO.read('cs-commons-site.json'))

		all_files = []
		Util.task("Finding files to check in") do
			['md', 'html', 'json', 'js', 'css', 'yml'].each do |ext|
				all_files.concat(Util.find_files_in('.', ext))
			end
			all_files.push('.gitignore') if File.exists?('.gitignore')
		end

		#puts "All files:"
		#all_files.each {|filename| puts filename}
		Util.task("Creating empty git repository") do
			Util.run_quiet('git', 'init')
			Util.run_quiet('git', 'checkout', '-b', 'gh-pages')
		end

		Util.task("Adding files") do
			cmd = ['git', 'add'].concat(all_files)
			#puts "All files: #{cmd.join('|')}"
			#puts "cmd.length=#{cmd.length}"
			Util.run_quiet(*cmd)
		end

		puts "Running git status:"
		Util.run('git', 'status')

		puts "If you want to make adjustments to the files to be added,"
		puts "I can run a shell for you."
		if Util.ask_yn("Would you like to start a shell?")
			puts "Starting a shell.  Exit the shell when you are ready to commit"
			puts "files to the repository."
			Util.run(ENV['SHELL'])
		end

		Util.task("Committing files") do
			Util.run_quiet('git', 'commit', '-mInitial checkin')
		end

		Util.task("Setting origin") do
			Util.run_quiet('git', 'remote', 'add', 'origin', site_meta['repo_git_url'])
		end

		Util.task("Pushing to origin") do
			Util.run_quiet('git', 'push', '-u', 'origin', 'gh-pages')
		end
	end
end

# ----------------------------------------------------------------------
# Register commands
# ----------------------------------------------------------------------
Command.add(Help.new)
Command.add(CreateSite.new)
Command.add(Checkin.new)

# ----------------------------------------------------------------------
# Function to print usage information
# ----------------------------------------------------------------------
def usage
	print <<"EOF"
Usage: cs-commons <command> [args]
Run "cs-commons help" for more information".
EOF
	exit(1)
end

# ----------------------------------------------------------------------
# Main code - figure out which command was requested and execute it
# ----------------------------------------------------------------------
usage if ARGV.length == 0

command_name = ARGV.shift
#puts "#{command_name}"

usage if !Command.all.has_key?(command_name)

begin
	Command.all[command_name].exec(ARGV)
rescue Exception => e
	puts "Error: #{e}"
	puts e.backtrace
	exit(1)
end

# vim:ts=2:
